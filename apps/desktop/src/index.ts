// Main process entry point
import { app, BrowserWindow, Tray, Menu, nativeImage, ipcMain, desktopCapturer, session, systemPreferences, shell, globalShortcut, clipboard, dialog } from 'electron';
import { autoUpdater } from 'electron-updater';
import WebSocket from 'ws';

// Initialize electron-audio-loopback for system audio capture
// This must be called before app is ready
import { initMain } from 'electron-audio-loopback';
initMain();

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const AMMO_TRACKER_WEBPACK_ENTRY: string;
declare const AMMO_TRACKER_PRELOAD_WEBPACK_ENTRY: string;
declare const TRAINING_WEBPACK_ENTRY: string;
declare const TRAINING_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// eslint-disable-next-line @typescript-eslint/no-require-imports
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Type definitions
type AudioCaptureStatus = 'idle' | 'connecting' | 'capturing' | 'error';

interface AudioCaptureConfig {
  callId?: string;
  teamId: string;
  closerId: string;
  prospectName?: string;
  sampleRate?: number; // Audio sample rate from AudioContext
}

let mainWindow: BrowserWindow | null = null;
let ammoTrackerWindow: BrowserWindow | null = null;
let trainingWindow: BrowserWindow | null = null;
let tray: Tray | null = null;
let isQuitting = false;

// Audio capture state
let audioStatus: AudioCaptureStatus = 'idle';
let wsConnection: WebSocket | null = null;
let currentCallId: string | null = null;

// Ammo tracker window state
let ammoTrackerVisible = false;

// Current logged-in closer ID (for training window)
let currentCloserId: string | null = null;

// Current team ID (for resources in ammo tracker)
let currentTeamId: string | null = null;

// Audio service URL - Production Railway deployment
const AUDIO_SERVICE_URL = process.env.AUDIO_SERVICE_URL || 'wss://amusing-charm-production.up.railway.app';

// Clerk configuration
const CLERK_PUBLISHABLE_KEY = process.env.CLERK_PUBLISHABLE_KEY || 'pk_test_cmVsZXZhbnQtZmluY2gtMzguY2xlcmsuYWNjb3VudHMuZGV2JA';
const CLERK_SECRET_KEY = process.env.CLERK_SECRET_KEY || 'sk_test_HlsHEnSRSzhOdHYGZMB6OdLXx00cPVHl6eY8kgT8pt';
const CLERK_FRONTEND_API = 'https://relevant-finch-38.clerk.accounts.dev';

// Custom protocol for auth callback
const PROTOCOL_NAME = 'sequ3nce';

// Pending magic link verification
let pendingMagicLinkEmail: string | null = null;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 400,
    height: 600,
    minWidth: 350,
    minHeight: 500,
    titleBarStyle: 'hiddenInset',
    backgroundColor: '#ffffff',
    show: false,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
      // Allow loading external scripts (needed for Clerk auth)
      webSecurity: false,
    },
  });

  // Set up display media request handler for system audio capture
  // This is the key to capturing loopback audio on macOS
  session.defaultSession.setDisplayMediaRequestHandler((request, callback) => {
    console.log('[Main] Display media request received');
    desktopCapturer.getSources({ types: ['screen'] }).then((sources) => {
      if (sources.length > 0) {
        console.log('[Main] Providing screen source with loopback audio');
        // Pass the first screen source with loopback audio
        callback({ video: sources[0], audio: 'loopback' });
      } else {
        console.error('[Main] No screen sources available');
        callback({});
      }
    }).catch((err) => {
      console.error('[Main] Error getting sources:', err);
      callback({});
    });
  });

  // Load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Show window when ready
  mainWindow.once('ready-to-show', () => {
    mainWindow?.show();
  });

  // Prevent window from closing, minimize to tray instead
  mainWindow.on('close', (event) => {
    if (!isQuitting) {
      event.preventDefault();
      mainWindow?.hide();
    }
  });

  // Open DevTools in development
  if (process.env.NODE_ENV === 'development' || process.defaultApp) {
    mainWindow.webContents.openDevTools({ mode: 'detach' });
  }
};

// Create the floating ammo tracker window
const createAmmoTrackerWindow = (): void => {
  if (ammoTrackerWindow) {
    ammoTrackerWindow.show();
    ammoTrackerWindow.focus();
    return;
  }

  // Get the main window bounds to position ammo tracker
  const mainBounds = mainWindow?.getBounds();
  const x = mainBounds ? mainBounds.x + mainBounds.width + 20 : 100;
  const y = mainBounds ? mainBounds.y : 100;

  ammoTrackerWindow = new BrowserWindow({
    width: 280,
    height: 400,
    minWidth: 240,
    minHeight: 300,
    maxWidth: 400,
    maxHeight: 600,
    x,
    y,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    skipTaskbar: true,
    resizable: true,
    hasShadow: true,
    backgroundColor: '#00000000',
    show: false,
    focusable: true, // Allow text input in notes field
    webPreferences: {
      preload: AMMO_TRACKER_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  ammoTrackerWindow.loadURL(AMMO_TRACKER_WEBPACK_ENTRY);

  // Show window when ready
  ammoTrackerWindow.once('ready-to-show', () => {
    ammoTrackerWindow?.showInactive(); // Show without focusing
    ammoTrackerVisible = true;

    // Send current call ID to the ammo tracker
    if (currentCallId) {
      ammoTrackerWindow?.webContents.send('ammo:call-id-changed', currentCallId);
    }
  });

  // Handle window close
  ammoTrackerWindow.on('closed', () => {
    ammoTrackerWindow = null;
    ammoTrackerVisible = false;
  });

  // Prevent the window from being closed by the user, just hide it
  ammoTrackerWindow.on('close', (event) => {
    if (!isQuitting) {
      event.preventDefault();
      ammoTrackerWindow?.hide();
      ammoTrackerVisible = false;
    }
  });

  // Open DevTools in development
  if (process.env.NODE_ENV === 'development' || process.defaultApp) {
    // Don't open devtools for ammo tracker by default to reduce clutter
    // ammoTrackerWindow.webContents.openDevTools({ mode: 'detach' });
  }
};

// Toggle ammo tracker window visibility
const toggleAmmoTracker = (): void => {
  if (!ammoTrackerWindow) {
    createAmmoTrackerWindow();
  } else if (ammoTrackerVisible) {
    ammoTrackerWindow.hide();
    ammoTrackerVisible = false;
  } else {
    ammoTrackerWindow.showInactive();
    ammoTrackerVisible = true;
    // Send current call ID when showing (in case it changed while hidden)
    if (currentCallId) {
      ammoTrackerWindow.webContents.send('ammo:call-id-changed', currentCallId);
    }
  }
};

// Create the training window
const createTrainingWindow = (): void => {
  if (trainingWindow) {
    trainingWindow.show();
    trainingWindow.focus();
    return;
  }

  trainingWindow = new BrowserWindow({
    width: 800,
    height: 600,
    minWidth: 600,
    minHeight: 400,
    title: 'Training',
    titleBarStyle: 'hiddenInset',
    backgroundColor: '#ffffff',
    show: false,
    webPreferences: {
      preload: TRAINING_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  trainingWindow.loadURL(TRAINING_WEBPACK_ENTRY);

  // Show window when ready
  trainingWindow.once('ready-to-show', () => {
    trainingWindow?.show();

    // Send current closer ID to the training window
    if (currentCloserId) {
      trainingWindow?.webContents.send('training:closer-id-changed', currentCloserId);
    }
  });

  // Handle window close
  trainingWindow.on('closed', () => {
    trainingWindow = null;
  });

  // Open DevTools in development
  if (process.env.NODE_ENV === 'development' || process.defaultApp) {
    // trainingWindow.webContents.openDevTools({ mode: 'detach' });
  }
};

const createTray = (): void => {
  // Create a simple tray icon from a data URL
  const icon = nativeImage.createFromDataURL(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAbwAAAG8B8aLcQwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAABrSURBVDiNY2AYBQMNGBkZ/1NSUhJhZGT8T4oeFHr+//+vwMDA8B8ZkKIHhYH//xkYGBgYcGkgRQ8KA+kGENKDyw1kA6J9QEgPLjfgBPj0EAXINoCQHqK8QEgPLjeQDXDpIRsQ0kNRiA8lAAApfkE9rChPUQAAAABJRU5ErkJggg=='
  );

  tray = new Tray(icon.resize({ width: 16, height: 16 }));

  const contextMenu = Menu.buildFromTemplate([
    {
      label: 'Show Sequ3nce',
      click: () => {
        mainWindow?.show();
        mainWindow?.focus();
      },
    },
    { type: 'separator' },
    {
      label: 'Toggle Ammo Tracker',
      accelerator: 'CommandOrControl+Shift+A',
      click: () => {
        toggleAmmoTracker();
      },
    },
    { type: 'separator' },
    {
      label: 'Start Recording',
      click: () => {
        mainWindow?.webContents.send('tray:start-recording');
      },
    },
    {
      label: 'Stop Recording',
      click: () => {
        mainWindow?.webContents.send('tray:stop-recording');
      },
    },
    { type: 'separator' },
    {
      label: 'Quit Sequ3nce',
      click: () => {
        isQuitting = true;
        app.quit();
      },
    },
  ]);

  tray.setToolTip('Sequ3nce');
  tray.setContextMenu(contextMenu);

  // Double-click to show window
  tray.on('double-click', () => {
    mainWindow?.show();
    mainWindow?.focus();
  });
};

// Update status and notify renderer
const updateStatus = (status: AudioCaptureStatus) => {
  audioStatus = status;
  mainWindow?.webContents.send('audio:status-change', status);
  console.log(`[Main] Audio status: ${status}`);
};

// End a call in the backend (used when connection drops unexpectedly)
const endCallInBackend = async (callId: string) => {
  try {
    console.log('[Main] Ending call in backend:', callId);
    const response = await fetch('https://ideal-ram-982.convex.site/endCall', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ callId, reason: 'connection_lost' }),
    });
    if (!response.ok) {
      console.error('[Main] Failed to end call in backend:', await response.text());
    } else {
      console.log('[Main] Call ended in backend successfully');
    }
  } catch (err) {
    console.error('[Main] Error ending call in backend:', err);
  }
};

// Connect to WebSocket server
const connectWebSocket = (config: AudioCaptureConfig & { callId: string }): Promise<boolean> => {
  return new Promise((resolve) => {
    console.log(`[Main] Connecting to WebSocket: ${AUDIO_SERVICE_URL}`);

    try {
      wsConnection = new WebSocket(AUDIO_SERVICE_URL);

      const timeout = setTimeout(() => {
        console.error('[Main] WebSocket connection timeout');
        wsConnection?.close();
        resolve(false);
      }, 10000);

      wsConnection.on('open', () => {
        clearTimeout(timeout);
        console.log('[Main] WebSocket connected');

        // Send metadata including sample rate for audio format verification
        const metadata = {
          callId: config.callId,
          teamId: config.teamId,
          closerId: config.closerId,
          prospectName: config.prospectName,
          sampleRate: config.sampleRate || 48000, // Include sample rate for WAV header
        };

        wsConnection!.send(JSON.stringify(metadata));
        console.log('[Main] Sent metadata:', metadata);
      });

      wsConnection.on('message', (data) => {
        try {
          const message = JSON.parse(data.toString());
          console.log('[Main] WebSocket message:', message);

          if (message.status === 'ready') {
            console.log('[Main] Server ready, can start streaming');

            // CRITICAL: Use the Convex-generated callId for all operations
            // The server returns convexCallId which is the actual database ID
            if (message.convexCallId) {
              console.log('[Main] Updating callId from:', currentCallId, 'to Convex ID:', message.convexCallId);
              currentCallId = message.convexCallId;

              // Notify renderer and ammo tracker of the correct call ID
              mainWindow?.webContents.send('audio:call-id-updated', message.convexCallId);
              if (ammoTrackerWindow) {
                ammoTrackerWindow.webContents.send('ammo:call-id-changed', message.convexCallId);
              }
            }

            resolve(true);
          } else if (message.error) {
            console.error('[Main] Server error:', message.error);
            mainWindow?.webContents.send('audio:error', message.error);
            resolve(false);
          }
        } catch (err) {
          console.error('[Main] Failed to parse message:', err);
        }
      });

      wsConnection.on('error', (err) => {
        clearTimeout(timeout);
        console.error('[Main] WebSocket error:', err);
        mainWindow?.webContents.send('audio:error', `Connection error: ${err.message}`);
        resolve(false);
      });

      wsConnection.on('close', () => {
        console.log('[Main] WebSocket closed');
        if (audioStatus === 'capturing') {
          updateStatus('error');
          mainWindow?.webContents.send('audio:error', 'Connection lost');

          // End the call in the backend when connection drops unexpectedly
          if (currentCallId) {
            endCallInBackend(currentCallId);
            currentCallId = null;
          }
        }
        wsConnection = null;
      });
    } catch (err) {
      console.error('[Main] Failed to create WebSocket:', err);
      resolve(false);
    }
  });
};

// Send audio data to WebSocket
const sendAudioData = (data: Buffer) => {
  if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
    wsConnection.send(data);
  }
};

// Close WebSocket connection
const closeWebSocket = async () => {
  if (wsConnection) {
    if (wsConnection.readyState === WebSocket.OPEN) {
      // Send end message
      wsConnection.send(JSON.stringify({ type: 'end' }));
      // Wait a bit for message to be sent
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    wsConnection.close();
    wsConnection = null;
  }
};

// ==================== Auth Functions ====================

// Web app URL for auth
const WEB_APP_URL = process.env.WEB_APP_URL || 'https://sequ3nce.ai';

// Send magic link - opens browser to web app's auth page
async function sendMagicLink(email: string): Promise<{ success: boolean; error?: string }> {
  try {
    console.log('[Auth] Opening browser for magic link auth:', email);
    pendingMagicLinkEmail = email;

    // Build the auth URL
    const authUrl = new URL(`${WEB_APP_URL}/desktop-auth`);
    authUrl.searchParams.set('email', email);
    authUrl.searchParams.set('redirect', `${PROTOCOL_NAME}://auth-callback`);

    // Open the browser to the auth page
    shell.openExternal(authUrl.toString());

    return { success: true };
  } catch (error) {
    console.error('[Auth] Error opening auth URL:', error);
    return {
      success: false,
      error: 'Failed to open login page. Please try again.'
    };
  }
}

// Verify session token
async function verifySession(token: string): Promise<boolean> {
  try {
    // For now, just check if the token exists and is non-empty
    // In production, you'd verify with Clerk's API
    return token && token.length > 0;
  } catch (error) {
    console.error('[Auth] Error verifying session:', error);
    return false;
  }
}

// Sign out
async function signOut(): Promise<void> {
  // Clear any stored session data
  pendingMagicLinkEmail = null;
}

// Handle the auth callback from the custom protocol
function handleAuthCallback(url: string): void {
  console.log('[Auth] Handling callback URL:', url);

  try {
    const parsedUrl = new URL(url);

    // Check for error
    const error = parsedUrl.searchParams.get('error');
    if (error) {
      console.error('[Auth] Auth error:', error);
      mainWindow?.webContents.send('auth:callback', { error: 'Authentication failed. Please try again.' });
      return;
    }

    // Get the email from the callback
    const email = parsedUrl.searchParams.get('email') || pendingMagicLinkEmail;

    // Check for token or session
    const token = parsedUrl.searchParams.get('token') ||
                  parsedUrl.searchParams.get('__clerk_ticket') ||
                  'authenticated'; // Fallback token if link was clicked

    if (token && email) {
      console.log('[Auth] Auth successful for:', email);
      // Update the pending email
      pendingMagicLinkEmail = email;
      mainWindow?.webContents.send('auth:callback', { token, email });
    } else if (token) {
      console.log('[Auth] Auth successful (no email in callback)');
      mainWindow?.webContents.send('auth:callback', { token });
    } else {
      console.error('[Auth] No token in callback');
      mainWindow?.webContents.send('auth:callback', { error: 'Invalid callback. Please try again.' });
    }
  } catch (error) {
    console.error('[Auth] Error parsing callback URL:', error);
    mainWindow?.webContents.send('auth:callback', { error: 'Invalid callback. Please try again.' });
  }
}

// ==================== IPC Handlers ====================

// Set up IPC handlers
const setupIpcHandlers = (): void => {
  console.log('[Main] Setting up IPC handlers...');

  // ---- Auth IPC Handlers ----

  ipcMain.handle('auth:send-magic-link', async (_event, email: string) => {
    return sendMagicLink(email);
  });

  ipcMain.handle('auth:verify-session', async (_event, token: string) => {
    return verifySession(token);
  });

  ipcMain.handle('auth:sign-out', async () => {
    return signOut();
  });

  // ---- Audio IPC Handlers ----

  // Get current audio capture status
  ipcMain.handle('audio:get-status', () => {
    return audioStatus;
  });

  // Check permissions (macOS screen recording)
  // Note: This is unreliable on macOS - 'screen' often shows 'denied' even when granted
  // We'll try to capture anyway and handle errors gracefully
  ipcMain.handle('audio:check-permissions', async () => {
    if (process.platform === 'darwin') {
      const status = systemPreferences.getMediaAccessStatus('screen');
      console.log(`[Main] Screen recording permission status: ${status}`);
      // Return true to allow attempting capture - real check happens in renderer
      // 'not-determined' means user hasn't been asked yet
      return status === 'granted' || status === 'not-determined';
    }
    return true;
  });

  // Request permissions - opens System Preferences on macOS
  ipcMain.handle('audio:request-permissions', async () => {
    if (process.platform === 'darwin') {
      // Open System Preferences to Screen Recording
      shell.openExternal('x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture');
      return false; // User needs to manually grant and restart
    }
    return true;
  });

  // Open system preferences directly
  ipcMain.handle('audio:open-preferences', () => {
    if (process.platform === 'darwin') {
      shell.openExternal('x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture');
    }
  });

  // Microphone permission handlers
  ipcMain.handle('audio:check-microphone-permission', async () => {
    if (process.platform === 'darwin') {
      const status = systemPreferences.getMediaAccessStatus('microphone');
      console.log(`[Main] Microphone permission status: ${status}`);
      return status; // 'not-determined', 'granted', 'denied', 'restricted', 'unknown'
    }
    return 'granted'; // Non-macOS platforms don't need this
  });

  ipcMain.handle('audio:request-microphone-permission', async () => {
    if (process.platform === 'darwin') {
      console.log('[Main] Requesting microphone permission...');
      const granted = await systemPreferences.askForMediaAccess('microphone');
      console.log(`[Main] Microphone permission granted: ${granted}`);
      return granted;
    }
    return true; // Non-macOS platforms don't need this
  });

  ipcMain.handle('audio:open-microphone-preferences', () => {
    if (process.platform === 'darwin') {
      shell.openExternal('x-apple.systempreferences:com.apple.preference.security?Privacy_Microphone');
    }
  });

  // Start audio capture - returns callId, actual capture happens in renderer
  ipcMain.handle('audio:start', async (_event, config: AudioCaptureConfig) => {
    console.log('[Main] Starting audio capture with config:', config);

    // SAFETY: Close any existing connection before starting a new one
    // This prevents duplicate calls if user clicks start multiple times
    if (wsConnection || currentCallId) {
      console.warn('[Main] Existing connection found, closing before starting new call');
      await closeWebSocket();
      currentCallId = null;
    }

    // Check screen recording permission first (macOS only)
    if (process.platform === 'darwin') {
      const screenStatus = systemPreferences.getMediaAccessStatus('screen');
      console.log('[Main] Screen recording permission status:', screenStatus);

      if (screenStatus !== 'granted') {
        // Show dialog to guide user
        const result = await dialog.showMessageBox(mainWindow!, {
          type: 'warning',
          title: 'Screen Recording Permission Required',
          message: 'Sequ3nce needs Screen Recording permission to capture audio from your sales calls.',
          detail: 'Click "Open Settings" and enable Sequ3nce in the Screen Recording list. You may need to click the "+" button to add it first.',
          buttons: ['Open Settings', 'Cancel'],
          defaultId: 0,
        });

        if (result.response === 0) {
          // Open System Settings to Screen Recording
          shell.openExternal('x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture');
        }

        return { success: false, error: 'Screen recording permission required' };
      }
    }

    if (!config.teamId || !config.closerId) {
      return { success: false, error: 'Missing teamId or closerId' };
    }

    // Generate call ID if not provided
    const { v4: uuidv4 } = await import('uuid');
    const callId = config.callId || uuidv4();
    currentCallId = callId;
    currentTeamId = config.teamId;

    // Update status to connecting
    updateStatus('connecting');

    // Connect to WebSocket
    const connected = await connectWebSocket({ ...config, callId });

    if (!connected) {
      updateStatus('error');
      currentCallId = null;
      return { success: false, error: 'Failed to connect to audio service' };
    }

    // Notify ammo tracker of new call (use currentCallId which has the Convex ID)
    if (ammoTrackerWindow) {
      ammoTrackerWindow.webContents.send('ammo:call-id-changed', currentCallId);
    }

    // Status will be updated to 'capturing' when renderer starts sending audio
    // Return currentCallId which has been updated to the Convex ID
    return { success: true, callId: currentCallId };
  });

  // Receive audio data from renderer and forward to WebSocket
  ipcMain.on('audio:data', (_event, data: ArrayBuffer) => {
    if (audioStatus === 'connecting') {
      // First audio data received, update status
      updateStatus('capturing');
    }

    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
      wsConnection.send(Buffer.from(data));
    }
  });

  // Receive audio level from renderer
  ipcMain.on('audio:level', (_event, level: number) => {
    mainWindow?.webContents.send('audio:level', level);
  });

  // Stop audio capture
  ipcMain.handle('audio:stop', async () => {
    console.log('[Main] Stopping audio capture...');

    await closeWebSocket();
    currentCallId = null;
    updateStatus('idle');

    // Notify ammo tracker that call ended
    if (ammoTrackerWindow) {
      ammoTrackerWindow.webContents.send('ammo:call-id-changed', null);
    }

    return { success: true };
  });

  // Get app version
  ipcMain.handle('app:get-version', () => {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const pkg = require('../package.json');
    return pkg.version;
  });

  // Get platform info
  ipcMain.handle('app:get-platform', () => {
    return {
      platform: process.platform,
      arch: process.arch,
    };
  });

  // Get audio service URL (for debugging)
  ipcMain.handle('audio:get-service-url', () => {
    return AUDIO_SERVICE_URL;
  });

  // ---- Ammo Tracker IPC Handlers ----

  // Get current call ID (for ammo tracker window)
  ipcMain.handle('ammo:get-call-id', () => {
    return currentCallId;
  });

  // Get current team ID (for resources in ammo tracker)
  ipcMain.handle('ammo:get-team-id', () => {
    return currentTeamId;
  });

  // Set team ID (called when closer logs in)
  ipcMain.handle('ammo:set-team-id', (_event, teamId: string) => {
    console.log('[Main] Setting teamId:', teamId);
    currentTeamId = teamId;
  });

  // Open URL in external browser (for resources)
  ipcMain.handle('ammo:open-external', (_event, url: string) => {
    shell.openExternal(url);
  });

  // Copy text to clipboard (from ammo tracker)
  ipcMain.handle('ammo:copy-to-clipboard', (_event, text: string) => {
    clipboard.writeText(text);
    console.log('[Main] Copied to clipboard:', text.slice(0, 50) + '...');
  });

  // Close ammo tracker window
  ipcMain.handle('ammo:close', () => {
    if (ammoTrackerWindow) {
      ammoTrackerWindow.hide();
      ammoTrackerVisible = false;
    }
  });

  // Toggle ammo tracker from main window
  ipcMain.handle('ammo:toggle', () => {
    toggleAmmoTracker();
    return ammoTrackerVisible;
  });

  // Get ammo tracker visibility status
  ipcMain.handle('ammo:is-visible', () => {
    return ammoTrackerVisible;
  });

  // Save notes to a call (via Convex HTTP endpoint)
  ipcMain.handle('ammo:save-notes', async (_event, callId: string, notes: string) => {
    try {
      const response = await fetch('https://ideal-ram-982.convex.site/updateCallNotes', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ callId, notes }),
      });

      if (!response.ok) {
        console.error('[Main] Failed to save notes:', response.statusText);
        return { success: false };
      }

      console.log('[Main] Notes saved for call:', callId);
      return { success: true };
    } catch (error) {
      console.error('[Main] Error saving notes:', error);
      return { success: false };
    }
  });

  // Get notes for a call
  ipcMain.handle('ammo:get-notes', async (_event, callId: string) => {
    try {
      const response = await fetch(`https://ideal-ram-982.convex.site/getCallNotes?callId=${encodeURIComponent(callId)}`);

      if (!response.ok) {
        return null;
      }

      const data = await response.json();
      return data.notes || null;
    } catch (error) {
      console.error('[Main] Error getting notes:', error);
      return null;
    }
  });

  // ---- Training Window IPC Handlers ----

  // Open training window
  ipcMain.handle('training:open', () => {
    createTrainingWindow();
    return true;
  });

  // Close training window
  ipcMain.handle('training:close', () => {
    if (trainingWindow) {
      trainingWindow.close();
      trainingWindow = null;
    }
    return true;
  });

  // Minimize training window
  ipcMain.handle('training:minimize', () => {
    if (trainingWindow) {
      trainingWindow.minimize();
    }
    return true;
  });

  // Get current closer ID
  ipcMain.handle('training:get-closer-id', () => {
    return currentCloserId;
  });

  // Set closer ID (called from main window when user logs in)
  ipcMain.handle('training:set-closer-id', (_event, closerId: string | null) => {
    currentCloserId = closerId;
    // Notify training window if it's open
    if (trainingWindow && closerId) {
      trainingWindow.webContents.send('training:closer-id-changed', closerId);
    }
    return true;
  });

  // Get assigned playlists for a closer
  ipcMain.handle('training:get-playlists', async (_event, closerId: string) => {
    try {
      const response = await fetch(
        `https://ideal-ram-982.convex.site/getAssignedTraining?closerId=${encodeURIComponent(closerId)}`
      );

      if (!response.ok) {
        console.error('[Main] Failed to get playlists:', response.statusText);
        return [];
      }

      const playlists = await response.json();
      return playlists;
    } catch (error) {
      console.error('[Main] Error getting playlists:', error);
      return [];
    }
  });

  // Get playlist details with items
  ipcMain.handle('training:get-playlist-details', async (_event, playlistId: string, closerId: string) => {
    try {
      const response = await fetch(
        `https://ideal-ram-982.convex.site/getTrainingPlaylistDetails?playlistId=${encodeURIComponent(playlistId)}&closerId=${encodeURIComponent(closerId)}`
      );

      if (!response.ok) {
        console.error('[Main] Failed to get playlist details:', response.statusText);
        return null;
      }

      const playlist = await response.json();
      return playlist;
    } catch (error) {
      console.error('[Main] Error getting playlist details:', error);
      return null;
    }
  });

  console.log('[Main] IPC handlers set up');
};

// Register the custom protocol handler
const registerProtocol = () => {
  // Register as the default protocol handler for sequ3nce://
  if (process.defaultApp) {
    if (process.argv.length >= 2) {
      app.setAsDefaultProtocolClient(PROTOCOL_NAME, process.execPath, [process.argv[1]]);
    }
  } else {
    app.setAsDefaultProtocolClient(PROTOCOL_NAME);
  }

  console.log(`[Main] Registered protocol handler for ${PROTOCOL_NAME}://`);
};

// This method will be called when Electron has finished initialization
app.whenReady().then(() => {
  // Register protocol first
  registerProtocol();

  createWindow();
  createTray();
  setupIpcHandlers();
  setupAutoUpdater(); // Initialize auto-updater

  // Request permissions on startup (macOS only)
  if (process.platform === 'darwin') {
    // Request microphone permission - this shows a prompt
    systemPreferences.askForMediaAccess('microphone').then((granted) => {
      console.log(`[Main] Microphone permission on startup: ${granted ? 'granted' : 'denied'}`);
    }).catch((err) => {
      console.error('[Main] Failed to request microphone permission:', err);
    });

    // Trigger screen recording registration by attempting to get sources
    // This makes the app appear in System Settings > Screen Recording
    // Note: This will fail if permission isn't granted, but it registers the app
    const screenStatus = systemPreferences.getMediaAccessStatus('screen');
    console.log(`[Main] Screen recording permission status: ${screenStatus}`);

    if (screenStatus !== 'granted') {
      // Attempt to get sources to register the app with TCC
      desktopCapturer.getSources({ types: ['screen'] }).then((sources) => {
        console.log(`[Main] Screen sources available: ${sources.length}`);
      }).catch((err) => {
        // This is expected to fail if permission is denied, but it registers the app
        console.log('[Main] Screen capture registration attempted (permission may be required):', err.message);
      });
    }
  }

  // Register global keyboard shortcut for ammo tracker
  globalShortcut.register('CommandOrControl+Shift+A', () => {
    toggleAmmoTracker();
  });

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    } else {
      mainWindow?.show();
    }
  });
});

// Handle protocol URL on macOS
app.on('open-url', (event, url) => {
  event.preventDefault();
  console.log('[Main] Received protocol URL:', url);

  if (url.startsWith(`${PROTOCOL_NAME}://auth-callback`)) {
    handleAuthCallback(url);
  }

  // Focus the main window
  if (mainWindow) {
    if (mainWindow.isMinimized()) mainWindow.restore();
    mainWindow.focus();
  }
});

// Handle protocol URL on Windows (single instance)
const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  app.quit();
} else {
  app.on('second-instance', (event, commandLine) => {
    // Someone tried to run a second instance, we should focus our window
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }

    // Handle the protocol URL on Windows
    const url = commandLine.find((arg) => arg.startsWith(`${PROTOCOL_NAME}://`));
    if (url) {
      console.log('[Main] Received protocol URL from second instance:', url);
      if (url.startsWith(`${PROTOCOL_NAME}://auth-callback`)) {
        handleAuthCallback(url);
      }
    }
  });
}

// Quit when all windows are closed, except on macOS
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Handle before quit
app.on('before-quit', async () => {
  isQuitting = true;
  globalShortcut.unregisterAll();
  await closeWebSocket();
});

// ==================== Auto-Update ====================

// Configure auto-updater
autoUpdater.autoDownload = true;
autoUpdater.autoInstallOnAppQuit = true;

// Set the GitHub release feed
autoUpdater.setFeedURL({
  provider: 'github',
  owner: 'Tallen231210',
  repo: 'sequ3nce-ai',
});

// Set up auto-updater event handlers
function setupAutoUpdater() {
  autoUpdater.on('checking-for-update', () => {
    console.log('[AutoUpdate] Checking for updates...');
  });

  autoUpdater.on('update-available', (info) => {
    console.log('[AutoUpdate] Update available:', info.version);
    // Notify the renderer that an update is available
    mainWindow?.webContents.send('update:available', info);
  });

  autoUpdater.on('update-not-available', (info) => {
    console.log('[AutoUpdate] App is up to date:', info.version);
  });

  autoUpdater.on('download-progress', (progress) => {
    console.log(`[AutoUpdate] Download progress: ${progress.percent.toFixed(1)}%`);
    mainWindow?.webContents.send('update:progress', progress);
  });

  autoUpdater.on('update-downloaded', (info) => {
    console.log('[AutoUpdate] Update downloaded:', info.version);
    
    // Show a dialog to the user
    dialog.showMessageBox(mainWindow!, {
      type: 'info',
      title: 'Update Ready',
      message: `A new version (${info.version}) has been downloaded.`,
      detail: 'Restart now to apply the update?',
      buttons: ['Restart Now', 'Later'],
      defaultId: 0,
    }).then((result) => {
      if (result.response === 0) {
        isQuitting = true;
        autoUpdater.quitAndInstall();
      }
    });
  });

  autoUpdater.on('error', (error) => {
    console.error('[AutoUpdate] Error:', error);
  });

  // Check for updates on startup (after a short delay)
  setTimeout(() => {
    autoUpdater.checkForUpdates().catch((err) => {
      console.error('[AutoUpdate] Failed to check for updates:', err);
    });
  }, 5000);

  // Check for updates every 4 hours
  setInterval(() => {
    autoUpdater.checkForUpdates().catch((err) => {
      console.error('[AutoUpdate] Failed to check for updates:', err);
    });
  }, 4 * 60 * 60 * 1000);
}

// IPC handler for manual update check
ipcMain.handle('update:check', async () => {
  try {
    const result = await autoUpdater.checkForUpdates();
    return { success: true, version: result?.updateInfo?.version };
  } catch (error) {
    console.error('[AutoUpdate] Manual check failed:', error);
    return { success: false, error: String(error) };
  }
});

// IPC handler for installing update
ipcMain.handle('update:install', () => {
  isQuitting = true;
  autoUpdater.quitAndInstall();
});
